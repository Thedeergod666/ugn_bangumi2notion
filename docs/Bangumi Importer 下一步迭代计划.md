这是非常扎实的进展！你已经完成了最枯燥的基础建设（设置、映射、搜索），现在的重点是如何把这些功能串联成一个**好用的日常工具**。

针对你提出的界面设计和疑问，我按模块逐一进行**产品逻辑梳理**与**技术实现建议**。

---

### 1. 全局导航与启动逻辑 (Navigation & Startup)

**Q: 未配置时默认打开哪里？配置后默认打开哪里？**

*   **PM 建议**：
    1.  **冷启动（首次安装/清除数据后）**：直接跳转 **设置页**（或一个引导页），因为没有 Token 和 Database ID，其他页面都是空的或报错，展示出来没有意义。
    2.  **热启动（已配置）**：建议默认打开 **新番放送页 (Calendar)**。
        *   *理由*：推荐页是“不知道看什么”时才去的，频率低；而新番页是“今天看什么/更新没”，频率高。作为工具类应用，高频功能前置。

**Q: 搜索页放哪里？**
*   **PM 建议**：不要把“搜索”作为一个单独的底部 Tab。
*   **设计**：将搜索入口做成 **顶部导航栏 (AppBar) 的放大镜图标** 或 **悬浮按钮 (FAB)**。
*   **理由**：搜索是一个“动作 (Action)”，不是一个“目的地 (Destination)”。无论你在新番页还是Notion页，随时可能想搜个新番，所以它应该是全局可达的。

---

### 2. 新番放送页 (Seasonal/Calendar) —— 核心首页

这是你应用最复杂、最亮点的页面，涉及**双源数据融合**。

**Q: 收藏按钮？手动置顶还是自动置顶？**
*   **PM 建议**：**自动置顶**（基于 Notion 绑定状态）。
*   **逻辑**：
    *   既然你已经在 Notion 里记录了这个番，说明你就在追。
    *   **不要让用户做两次操作**（Notion 导入一次，这里又点一次收藏）。
    *   **排序规则**：已绑定 (Notion中存在) > 未绑定 (BGM原数据)。
    *   **显示状态**：已绑定（绿色卡片/边框），未绑定（灰色/普通）。

**Q: 已更多少集的数据展示？**
*   这需要**混合数据源**（这是技术难点，但体验极佳）。
*   **实现方案**：
    1.  **API 请求**：调用 Bangumi Calendar API 获取本周番剧列表。
    2.  **本地查询**：拿到列表后，遍历 BGM ID，去 Notion 查（或者查本地缓存的 Notion 映射表）是否存在该 ID。
    3.  **UI 渲染**：
        *   **卡片头部**：番剧封面 + 标题。
        *   **卡片状态栏**：
            *   如果有绑定：显示 `Notion进度: 3` / `BGM最新: 4` (数据来源：Notion 已看集数 / BGM Calendar 数据)。
            *   如果没绑定：只显示 `BGM最新: 4`。

---

### 3. 推荐页 (Recommendation)

**Q: 只是从 Notion 获取数据的话，可以不用 Notion AppID 吗？**
*   **技术回答**：**必须用**。
*   **解释**：Notion 的数据是私有的。即使是读数据，也需要 `Integration Token` (你说的 AppID) 才有权限访问 Database。不传 Token API 会报 401 Unauthorized。

**实现逻辑**：
*   **Query**：`POST /v1/databases/{db_id}/query`。
*   **Filter**：`Filter: { property: "悠gn评分", number: { greater_than_or_equal_to: 6.5 } }`。
*   **Sort**：Notion API **不支持随机排序**。
    *   *变通方法*：你需要在 Flutter 端把符合条件的数据（比如 50 条）拉下来，然后在本地代码里执行 `list.shuffle()`，取前 1 题展示。

---

### 4. 主页/搜索页 (Search & Import)

你关于“更新”的逻辑（自选更新内容、默认不选标签）我们在上一次讨论中已经定好了，保持那个方案即可。

**关于“Bangumi数据更新日期”字段**：
*   建议加。这是一个很好的“元数据”，让你知道 Notion 里的信息是不是一年前的老黄历。

**关于“图片URL放正文”**：
*   更新时如果不勾选正文，确实不需要动。如果勾选了，建议采用 **Append (追加)** 模式，防止把用户自己写的吐槽覆盖掉。

---

### 5. Notion 页 (Progress Manager)

这个页面是你进行 **反向同步 (Reverse Sync)** 的阵地。

**设计建议**：
*   **布局**：列表视图。
*   **筛选**：默认只显示 `追番状态 == 在看` 的条目（不要把几百个已看/想看都拉出来，加载慢）。
*   **排序**：`最近更新` (Notion计算出的时间) 倒序。
*   **卡片操作**：
    *   **左侧**：标题 + 下一集时间 (公式计算)。
    *   **右侧**：一个明显的 **同步按钮**。
    *   **交互**：
        1.  点击同步按钮。
        2.  Flutter 读取当前条目的 `已看集数` (例如 5)。
        3.  Flutter 调用 Bangumi API `updateCollection`，把进度设为 5。
        4.  提示“同步成功”。

---

### 6. 影视/游戏页 (Future Scope)

**PM 建议**：**V1.0 版本砍掉**。
*   **理由**：做减法。先把 Bangumi 这一条线跑通、跑顺。豆瓣 API 目前很难搞（需要复杂的爬虫或第三方私有 API），Steam API 又是另一套逻辑。不要让这些未完成的功能拖慢你发布的节奏。可以先留个入口，点击提示“敬请期待”。

---

### 7. 技术实现路线图 (Implementation Roadmap)

基于你的现状，建议的开发顺序：

#### 阶段一：配置与路由 (Infrastructure)
1.  **完善 `main.dart`**：
    *   启动时读取 `SharedPreferences`。
    *   判断 `bgm_token` 和 `notion_token` 是否存在。
    *   存在 -> `HomePage` (即新番页)。
    *   不存在 -> `SettingsPage`。
2.  **完善 `SettingsPage`**：
    *   确保 Database ID 分别存储（番剧 DB ID, 影视 DB ID...）。

#### 阶段二：新番放送页 (Calendar) - *最能打动用户的功能*
1.  封装 Bangumi Calendar API。
2.  实现“双源数据合并”逻辑：
    ```dart
    // 伪代码思路
    class DailyBangumi {
       Subject subject; // BGM 数据
       NotionPage? boundPage; // Notion 数据 (如果已绑定)
     
       bool get isBound => boundPage != null;
    }
  
    // 获取数据流程
    1. calendarList = await bgmApi.getCalendar();
    2. trackedIds = await notionApi.getAllBangumiIds(); // 这是一个只拉取 ID 列的轻量请求
    3. mergedList = calendarList.map((item) {
         if (trackedIds.contains(item.id)) {
            // 标记为已绑定，甚至可以去拉取详细进度
         }
         return item;
    });
    4. mergedList.sort((a, b) => a.isBound ? -1 : 1); // 已绑定置顶
    ```

#### 阶段三：Notion 管理页 (Progress)
1.  实现 `NotionService.queryWatchingList()`。
2.  实现 `BangumiService.updateProgress(id, ep)`。

#### 阶段四：UI 润色与发布
1.  夜间模式适配。
2.  侧边栏 (Drawer) 导航连接各页。

---

**总结**：
你的设计大方向是对的。
**关键调整点**：
1.  把“新番放送”作为默认主页。
2.  把“搜索”改成全局入口。
3.  利用 Notion 绑定状态来实现自动置顶（放弃手动收藏）。
4.  Notion API 必须要 Token 才能读数据。

这套逻辑下来，整个 App 的使用流非常顺畅：
**每天打开 App (看新番页) -> 发现今天有更新 (置顶显示) -> 去看番 -> 看完在 App (Notion页) 点一下同步 -> 完美。**




------------------------------------------------------------------



## 1) 先回答你问的关键点：Notion 需要 “appid” 吗？

**不需要。**
Notion 的公开 API 目前主要有两种接入方式：

1) **Internal Integration Token（你现在用的 Token）**：
- 只需要 `Notion Token + Database ID`
- 不存在你说的 “appid” 概念（那是 OAuth Client 的 client_id/client_secret 才会有）

2) **OAuth（给别人用才需要）**：
- 才会涉及 `client_id / client_secret / redirect_uri`
- 你现在做个人工具，完全可以不做

所以：**推荐页/新番放送页如果只是从 Notion 读数据，也只需要 Token + Database ID**（前提是你要读 Notion）。

---

## 2) 信息架构（IA）与启动默认页：怎么更合理？

你在纠结：未配置 Notion 时默认进“新番放送页”还是“配置页”。

### 建议的启动策略（最不容易让用户困惑）
做一个**启动判定状态机**：

- **未配置 Bangumi（或 Token 失效）** → 进入【设置页】并提示完成授权
- **已配置 Bangumi，但未配置 Notion（Token/DBID 缺失）** → 进入【搜索页】或【新番放送页】都行，但要明显提示“未绑定 Notion，仅可浏览/收藏，导入需配置”
- **Bangumi + Notion 都配置完成** → 默认进入【推荐页】

这样做的原因：
- 你产品的核心价值是“同步到 Notion”，但在未配置时仍应允许用户“先看内容再决定要不要配”（降低第一次使用门槛）。

### 默认页推荐（结合你当前实现成本）
- **V1（你现在阶段）**：未配置 Notion → 直接进【设置页】（最简单、减少状态分支）
- **V1.1**：未配置 Notion → 进【新番放送页】但顶部 Banner 强提示去设置（体验更好）

---

## 3) 页面优先级重排：你现在该先做哪些页，哪些先别做

你现在已实现：**设置页、映射页、搜索页**。非常好。下一步建议按“价值/复杂度”排序：

### P0（必须做，打通主闭环）
1. **导入/更新弹窗（Import/Update Sheet）**：
   - 新建 / 通过 Bangumi ID 更新 / 通过 Notion Unique ID 绑定更新
   - 字段勾选（默认勾选映射项）
   - 标签自选（默认不选）
   - 写入 `bangumi数据更新日期`

2. **Notion 数据库 Schema 拉取与校验**（设置页保存后做一次）：
   - `GET /v1/databases/{database_id}` 拉属性名 + 类型
   - 映射页里 Notion 字段下拉列表显示：`属性名 (类型)`，避免用户映射错类型导致写入失败

### P1（强体验提升，但可以后置）
3. **新番放送页**（从 Bangumi 拉当季/本周放送）
4. **推荐页**（从 Notion query 得到评分>=6.5 随机/按规则推荐）

### P2（复杂且依赖更多数据）
5. **Notion页（最近观看/进度反向同步）**
6. **影视页/豆瓣**（反爬/接口不稳定，建议很后面再碰）

---

## 4) 你提到的新番放送页：收藏/置顶/已绑定显示，怎么设计更省事？

### 4.1 “收藏置顶” vs “已绑定置顶”
这两者不冲突，但我建议你先做一个原则：

- **默认排序**：已绑定（Notion 内有记录）优先 > 收藏优先 > 其他
- 收藏更像是“我特别关注”，但已绑定意味着“我在管这个条目”，优先级更高更符合你的使用目的

### 4.2 已绑定（绿色）/未绑定（灰色）怎么实现？
这是个非常高性价比的功能，但实现方式要选对，否则会很慢：

- **粗暴做法（不推荐）**：每个新番条目都去 Notion query 一次看是否存在 → 性能灾难
- **推荐做法**：启动新番放送页时：
  1) Notion 侧一次性 query 拿到你库里所有 `bangumi识别id`（或拿最近 N 条 + 在看/想看状态）
  2) 本地做一个 `Set<int> notionBgmIds`
  3) 渲染时 `set.contains(subjectId)` 决定显示已绑定/未绑定

这能保证体验丝滑。

### 4.3 “已追3/已更4/总共12”放哪里更合适？
你直觉对：**放在新番放送页展示更有意义**，因为它是“每日浏览入口”。

但注意：如果你不每天打开 App，你也无法每日刷新“已更4”。
所以这里建议：
- **已追（来自 Notion 已看集数）**：可以非常准确（因为 Notion 是你的主账本）
- **已更（来自 Bangumi 章节 airdate 计算）**：需要实时算，但你只要打开时算一次就行（不需要每天后台）

---

## 5) 搜索页/主页：要不要合并到新番放送页？

产品上更推荐：**搜索是一个全局动作，不应该藏在某个内容页里。**
实现上你可以：

- 侧边栏固定入口：推荐 / 新番放送 / 搜索 / 映射 / 设置
- 或底部导航：推荐｜新番｜搜索｜Notion｜设置（如果移动端）

你现在是桌面端风格（侧边栏），保留“搜索”独立入口是合理的。

---

## 6) “更新 Bangumi 数据至 Notion”的具体实现建议（结合你的页面规划）

你在主页里提到两件事：导入 & 更新。实际上它们可以统一为一个概念：**Upsert（不存在则创建，存在则更新）**。

### 6.1 导入/更新在交互上怎么统一
在番剧详情 → 导入页中加一个「目标」区块：

- 新建 Notion 页面（默认）
- 更新已导入条目（当检测到 Notion 有该 Bangumi ID 时默认选中）
- 绑定并更新旧条目（输入 Notion Unique ID）

然后字段勾选 + 标签自选保持一致。

### 6.2 更新策略（默认值建议）
- 默认勾选：放送开始、制作人员、评分、链接、Bangumi ID、更新日期
- 默认不勾选：正文图片/简介、标签
- 额外提供一个开关：**“仅填空（不覆盖已有）”**（个人工具里非常有用）

---

## 7) 你接下来可以按这个“开发顺序”推进（最实操）

1. 设置页保存后：拉取 Notion Database schema（properties+title property name）并缓存
2. 映射页：Notion 字段下拉展示 `name + type`，并校验映射类型
3. 详情页 → 导入页：
   - 自动检测是否已存在 Bangumi ID
   - 渲染字段勾选列表（来自映射表）
   - 标签 chips 自选
   - “新建/更新/绑定”三模式
4. 实现 Notion：`query -> create/patch -> append blocks(可选)`
5. 再做：推荐页/新番放送页（都是读 API，不影响主闭环）

---

如果你愿意，我可以基于你现有的侧边栏结构，给一版更具体的 **导航结构图 + 每个页面的 P0/P1 组件清单**；或者你把“当前路由/页面文件结构”贴出来，我按你的代码结构给出落地实现建议（哪些 Service/Repository 该新增、状态该怎么管理）。